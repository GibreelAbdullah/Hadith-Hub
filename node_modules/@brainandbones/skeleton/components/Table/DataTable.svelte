<script>import { createEventDispatcher } from 'svelte';
import { sortAsc, sortDesc } from './DataTableService';
const dispatch = createEventDispatcher();
// Props
export let headings = [];
export let source = [];
export let search = '';
export let sort = '';
export let count = source.length;
export let interactive = false;
export let async = false;
// Props: Design
export let header = 'bg-surface-200-700-token';
export let body = 'bg-surface-100-800-token';
export let text = 'text-sm';
export let color = '';
export let hover = 'bg-hover-token';
// A11y
export let labelledby = '';
export let describedby = '';
// Local
let elemTable;
let sourceUnfiltered = [...source]; // clone
let sorted = { by: sort, asc: false };
// Base Classes
const cBase = 'space-y-4';
const cBaseWrapper = 'overflow-x-auto w-full rounded-container-token border-[1px] border-neutral-900/5 dark:border-neutral-50/5 border-inset';
const cBaseTable = 'w-full overflow-hidden table-auto';
const cBaseEmpty = 'p-4 text-center';
// ---
const cBaseHead = '';
const cBaseHeadRow = 'capitalize font-medium text-left';
const cBaseHeadCol = `p-3 py-4 whitespace-nowrap cursor-pointer`;
// ---
const cBaseBody = '';
const cBaseBodyRow = 'border-t border-neutral-900/5 dark:border-neutral-50/5 even:bg-black/[2%]';
const cBaseBodyCol = 'p-3 font-medium whitespace-nowrap md:whitespace-normal';
function headKeyByIndex(i) {
    return Object.keys(source[0])[i];
}
function onHeadSelect(i) {
    const column = headKeyByIndex(i);
    dispatch('sorted', column);
    async ? (sorted.by = column) : localSort(column);
}
function onRowSelect(r) {
    if (interactive === true) {
        dispatch('selected', r);
    }
}
// Sort
function localSort(column) {
    if (!source.length)
        return;
    // If same column, toggle asc/desc
    if (column === sorted.by) {
        sorted.asc = !sorted.asc;
        sorted.asc ? sortAscending(column) : sortDescending(column);
        // If new column, sort asc
    }
    else {
        sorted.asc = true;
        sortAscending(column);
    }
    // Update states
    sorted.by = column;
    updateRowCount();
}
function sortAscending(key) {
    source = sortAsc(source, key);
}
function sortDescending(key) {
    source = sortDesc(source, key);
}
// Search
function localSearch() {
    if (async)
        return;
    source = sourceUnfiltered.filter((row) => {
        const match = JSON.stringify(Object.values(row)).toLowerCase().includes(search.toLowerCase());
        if (match)
            return row;
    });
    updateRowCount();
}
// Count
function updateRowCount() {
    count = source.length;
}
// A11y Input Handler
// prettier-ignore
function onKeyDown(event) {
    // Arrow Keys
    const hotKeys = ['ArrowRight', 'ArrowUp', 'ArrowLeft', 'ArrowDown', 'Home', 'End'];
    if (hotKeys.includes(event.code)) {
        event.preventDefault();
        // prettier-ignore
        switch (event.code) {
            case 'ArrowUp':
                setActiveCell(0, -1);
                break;
            case 'ArrowDown':
                setActiveCell(0, 1);
                break;
            case 'ArrowLeft':
                setActiveCell(-1, 0);
                break;
            case 'ArrowRight':
                setActiveCell(1, 0);
                break;
            case 'Home':
                jumpToOuterColumn('first');
                break;
            case 'End':
                jumpToOuterColumn('last');
                break;
            default: break;
        }
    }
}
function setActiveCell(x, y) {
    // Focused Element
    const focusedElem = document.activeElement;
    if (!focusedElem || !focusedElem.parentElement || !focusedElem.parentElement.ariaRowIndex || !focusedElem.ariaColIndex)
        return;
    const focusedElemRowIndex = parseInt(focusedElem.parentElement.ariaRowIndex);
    const focusedElemColIndex = parseInt(focusedElem.ariaColIndex);
    // Target Element
    const targetRowElement = elemTable.querySelector(`[aria-rowindex="${focusedElemRowIndex + y}"]`);
    if (targetRowElement !== null) {
        const targetColElement = targetRowElement.querySelector(`[aria-colindex="${focusedElemColIndex + x}"]`);
        if (targetColElement !== null) {
            targetColElement.focus();
        }
    }
}
function getTargetElem() {
    // Focused Element
    const focusedElem = document.activeElement;
    if (!focusedElem || !focusedElem.parentElement || !focusedElem.parentElement.ariaRowIndex)
        return null;
    const focusedElemRowIndex = parseInt(focusedElem.parentElement.ariaRowIndex);
    // Return Target Element
    return elemTable.querySelector(`[aria-rowindex="${focusedElemRowIndex}"]`);
}
function jumpToOuterColumn(type = 'first') {
    const targetRowElement = getTargetElem();
    if (targetRowElement === null)
        return;
    const lastIndex = targetRowElement.children.length;
    const selected = type === 'first' ? 1 : lastIndex;
    const targetColElement = targetRowElement.querySelector(`[aria-colindex="${selected}"]`);
    if (targetColElement === null)
        return;
    targetColElement.focus();
}
// On Prop Change
$: if (sort) {
    localSort(sort);
}
$: if (search || search === '') {
    localSearch();
}
// Reactive Classes
$: classesBase = `${cBase} ${$$props.class ?? ''}`;
$: classesTable = `${cBaseTable} ${text} ${color}`;
$: classesHeader = `${cBaseHead} ${header}`;
$: classesHeadCol = `${cBaseHeadCol} ${hover}`;
$: classesBody = `${cBaseBody} ${body}`;
$: cRowInteractive = interactive ? `${hover} cursor-pointer` : '';
$: classesBodyRoll = `${cBaseBodyRow} ${cRowInteractive}`;
</script>

<div class="data-table {classesBase}" data-testid="data-table">
	<!-- Header -->
	{#if $$slots.header}<header class="table-header"><slot name="header" /></header>{/if}

	<!-- Wrapper -->
	<div class="table-wrapper {cBaseWrapper}">
		<!-- Table -->
		<table
			bind:this={elemTable}
			class="table {classesTable}"
			on:keydown={onKeyDown}
			role="grid"
			aria-labelledby={labelledby}
			aria-describedby={describedby}
			aria-colcount={headings.length}
			aria-rowcount={source.length}
		>
			<!-- Head -->
			<thead class="table-head {classesHeader}">
				<!-- Head -->
				<tr class="table-head-row {cBaseHeadRow}">
					{#each headings as head, i}
						<th
							class="table-head-col {classesHeadCol}"
							scope="col"
							on:click={() => {
								onHeadSelect(i);
							}}
							role="columnheader"
						>
							{@html head}
							<span class="inline-block w-3 text-center ml-1 opacity-50">
								{#if headKeyByIndex(i) === sorted.by}
									{@html sorted.asc ? '&darr;' : '&uarr;'}
								{/if}
							</span>
						</th>
					{/each}
				</tr>
			</thead>

			<!-- Body -->
			<tbody class="table-body {classesBody}">
				{#if source.length > 0}
					{#each source as row, rowIndex}
						<tr
							class="table-body-row {classesBodyRoll}"
							on:click={() => {
								onRowSelect(row);
							}}
							aria-rowindex={rowIndex + 1}
						>
							{#each Object.values(row) as cell, colIndex}
								<td class="table-body-col {cBaseBodyCol}" role="gridcell" aria-colindex={colIndex + 1} tabindex={colIndex === 0 ? 0 : -1}>{@html cell}</td>
							{/each}
						</tr>
					{/each}
				{:else}
					<!-- Empty -->
					<tr
						><td colspan={headings.length} class="table-empty {cBaseEmpty}">
							{#if $$slots.empty}<slot name="empty" />{:else}No results available.{/if}
						</td></tr
					>
				{/if}
			</tbody>
		</table>
	</div>

	<!-- Footer -->
	{#if $$slots.footer}<footer class="table-footer"><slot name="footer" /></footer>{/if}
</div>
